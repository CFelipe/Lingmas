Quando definimos tipos abstratos de dados, classes, módulos
e pacotes, usamos de encapsulamentos  mínimos, ou seja, coleções pequenas
de código e data logicamente relacionado, de modo a criar uma abstração
para o usuário. Essas coleções são chamadas de encapsulamento.
Mas quando o código começa a crescer na casa das milhares de linhas de
código, utilizamos esse conceito de forma expandida.

Em C, uma coleção de funções e dados relacionados podem ser colocadas em
arquivos compilados separadamente, agindo como uma biblioteca. A interface para
tal arquivo é colocada em um arquivo separado, chamado de header file (arquivo
de cabeçalho). Quando o pré-processador lê uma declaração de
\inlinecode{\#include}, como \inlinecode{\#include "biblioteca.h"}, o conteúdo do
arquivo de cabeçalho (neste caso, \inlinecode{biblioteca.h}) é inserido. Esse
tipo de encapsulamento gera algumas inseguranças. Por exemplo, o código do
\emph{header} pode ser simplesmente copiado e colado, em vez de usar o
\inlinecode{\#include}. Inicialmente, isso não faz diferença, porém quando o
autor da biblioteca faz alterações, o \emph{linker} pode não detectar a
incompatibilidade de tipos entre as definições antigas (copiadas e coladas) e
as implementações novas.

Decidimos adotar o mesmo funcionamento para nossa linguagem, apesar da
insegurança, já que o conceito é simples e útil, e não temos como objetivo dar
suporte ao desenvolvimento de aplicações muito grandes. Pelo mesmo motivo, não
teremos encapsulamento de nomes, pois os programas não devem ser grandes o
suficiente para poder causar conflito de nomes.
