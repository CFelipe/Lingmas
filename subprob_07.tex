\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel} % Hifenização e dicionário
\usepackage[left=3.00cm, right=2.00cm, top=3.00cm, bottom=2.00cm]{geometry}
\usepackage{enumitem} % Para itemsep etc
\usepackage{longtable} % Dependência do longtabu
\usepackage{tabu} % Para melhor criação de tabelas
\usepackage{color}
\usepackage{parskip} % Linha em branco entre parágrafos em vez de recuo
\usepackage{graphicx}
\usepackage[breaklinks]{hyperref}

\tabulinesep=0.75ex % Espaçamento interno das tabelas

\begin{document}
    \begin{center}
        \textsc{Universidade Federal do Rio Grande do Norte} \\
        \textsc{Departamento de Informática e Matemática Aplicada}
    \end{center}

    \bigskip

    \begin{tabular}{@{}ll@{}}
            \emph{Disciplina:} & DIM0437 --- Linguagens de Programação:
                                 Conceitos e Paradigmas \\
            \emph{Docente:}    & Umberto Souza da Costa \\
            \emph{Discentes:}  & Dogival Ferreira da Silva Junior \\
                               & Felipe Cortez de Sá \\
                               & Gabriel Sebastian von Conta \\
                               & Phellipe Albert Volkmer \\
                               & Vinícius Araújo Petch
    \end{tabular}

    \bigskip

    \begin{center}
        \large \textbf{Subproblema 7} --- Subprogramas
    \end{center}

    \section{Problema}
        \subsection{Produto do problema}
        Definição da sintaxe e semântica intuitiva dos mecanismos que regem as
        formas de abstração de processamento (procedimentos e funções) da
        linguagem de programação a ser definida pelo grupo. Incluir a
        representação destas abstrações, assim como os mecanismos de passagem
        de parâmetros e a implementação sugerida.

        \subsection{Questões}
        \begin{enumerate}
            \item
            Como serão definidos os procedimentos e funções de sua linguagem?
            Note que estes conceitos são diferentes, embora sejam tratados de
            forma unificada por algumas linguagens de programação. Quais são as
            diferenças entre esses conceitos?

            \item
            Como serão definidos os parâmetros da linguagem? Quais dados
            poderão ser colocados como argumentos em chamadas a procedimentos e
            funções? Nomes de subprogramas poderão ser utilizados como
            parâmetros?

            \item
            Quais serão as formas de passagem de parâmetros e como serão
            implementadas?

            \item
            Sua linguagem verificará os tipos de parâmetros dos subprogramas?

            \item
            A linguagem terá subprogramas sobrecarregados ou genéricos?

            \item
            A linguagem deverá ter compilação separada ou independente?

            \item
            Sua linguagem dará suporte a co-rotinas?
        \end{enumerate}

    \section{Resoluções}
        \begin{enumerate}
            \item
            Na nossa linguagem usaremos ambos, funções e procedimentos, com o objetivo de deixar claro ambos os conceitos para facilitar o aprendizado dos nossos usuários. Definindo sintaticamente uma função, temos:

            Ambas são abstrações de processo (subprogramas) e se eu vier perguntar qual deles se assemelha a um comando (???): procedimento
            
            <function> 	::= function id "(" <parameters_list> ")" "{"
            <stmts> 
            <return> 
            "}"
            
            Definindo sintaticamente um procedimento, temos:
            
            <procedure>	::= procedure id "(" <parameters_list> ")" "{"
            			<stmts>
            			"}"
            
            A diferença conceitual entre procedimento e função reside na ausência de retorno nos procedimentos, normalmente os procedimentos alteram o programa principal.

            \item
            Os parâmetros em nossa linguagem poderão ser de qualquer tipo da linguagem, inclusive os tipos criados pelo usuário.
        	A utilização de parâmetros será de forma posicional, uma vez que, como a maior parte dos programas será curto, não são necessários keyword parameters, que diminuiriam a capacidade de escrita do nosso código e o tornaria muito extenso.
        	Subprogramas não poderão ser utilizados como argumentos, uma vez que acarretaria em uma queda de legibilidade para o programa. Além disso, novamente, como o caráter dos subprogramas é simples, pode-se facilmente atribuir o valor de um subprograma à uma variável e então usar essa variável como argumento.

            \item
            Nós teremos passagem por valor, implementado por cópia, e passagem por referência. 
            \item
            Sim, ela utilizará o método de protótipo.
            \item
            Não teremos subprogramas com sobrecarga ou genéricos.

            Com sobrecarga:
            
            	int soma(int a, int b)
            {
            return a+b;
            }
            	
            	float soma(float a, float b)
            {
            return a+b;
            }
            
            	int soma(String a, String b)
            {
            return a^b;
            }
            
            	Final das contas, posso lembrar o nome de apenas uma função e fazer:
            
            	soma(1, 2);
            	soma(1.5, 2.5);
            	soma(“teste”, “ ftw”);	
            
            	Sem sobrecarga:
            	
            	int somaInt(int a, int b)
            {
            return a+b;
            }
            	
            	float somaFloat(float a, float b)
            {
            return a+b;
            }
            
            	int somaString(String a, String b)
            {
            return a^b;
            }
            
            	Final das contas vou ter que lembrar do nome de 3funções
            
            	Para códigos gigantes com centenas de funções, isso faz diferença .-.

            \item

            \item
            
        \end{enumerate}
\end{document}
